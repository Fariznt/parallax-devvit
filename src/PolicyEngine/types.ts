// === LLM arguments to PolicyEngine ===

export type ModelConfig = {
  modelName: string;
  baseUrl: string;
};

export type ModelRegistry = {
  default: string | null;
  presets: Record<string, ModelConfig>; // key used in policy definition -> config
};

export type ApiKeys = Record<string, string> // same key -> api key strings

// === Definitions for Policy definition ===

export type SafetyCategory =
  | "sexual"
  | "sexual/minors"
  | "harassment"
  | "harassment/threatening"
  | "hate"
  | "hate/threatening"
  | "illicit"
  | "illicit/violent"
  | "self-harm"
  | "self-harm/intent"
  | "self-harm/instructions"
  | "violence"
  | "violence/graphic";

export type SafetyRule =
  {
    category: SafetyCategory; // category for this rule
		// at least one of escalation_range or violation_range
		// if score in violation_range => instant violation with no next_check
		// otherwise if score in escalation_range => go to next_check
    escalation_range?: [number, number];
    violation_range?: [number, number];
  } & (
    | { escalation_range: [number, number] }
    | { violation_range: [number, number] }
  );

export type SafetySpecification =
	// simple option; if category = True according to moderation API, violation 
	// (and escalate if next-check present)
	| { categories: SafetyCategory[] } 
	// advanced option; 
	| { rules: SafetyRule[] } 

// NodeSpecification: Defines types of checks and their fields
export type NodeSpecification = {
	// core functionality
  match_check: { 
		patterns: string[];
    blacklist?: boolean; // considered false by default i.e. pattern is whitelist
		flags?: string;
	};
	safety_check: {
		scope: 'text' | 'image' | 'both';
	} & SafetySpecification;
  semantic_check: { semantic: string };
	language_check: { allowed: string[] }; // to be implemented using language.googleapis.com
  // NEW CHECKS ADDED HERE (subsets of match/safety, length, capitalization percentage)
};

// A type of check of the content
export type Predicate = {
  [K in keyof NodeSpecification]: {
    [P in K]: NodeSpecification[K];
  }
}[keyof NodeSpecification]

// A logical operator on predicate output (for aggregate values and negation)
export type Combinator =
    | { any_of: Policy[] }
    | { all_of: Policy[] }
    | { not: Policy[] | Policy }

// The representation of the content policy itself (the root or other nodes)
// Generated by parsing input JSON
export type Policy = {
  name?: string;
  next_check?: Policy;
	severity?: number; // optional severity score for violating this check
} & (Predicate | Combinator);

// === Definitions for PolicyEngine evaluation output ===

// Information corresponding to some predicate, returned by evaluateHelper so that
// expensive calls can be done with batching of all checks that wanted to use the 
// expensive tool (ex. LLM)
export type DeferredCheck = {
	type: 'semantic_check';
	rule: string;
	negate: boolean // flipped by a NOT node
  node_id: NodeIdentifier 
}

export type NodeType = 
  | "match_check" | "safety_check" | "semantic_check" 
  | "language_check" | "all_of" | "any_of" | "not" // NEW CHECKS ADDED HERE

export type NodeResult = 
"pass" | "fail" | "deferred" | null // null means not yet evaluated 

// An identifier of nodes in the policy-tree generated lazily at evaluation time
// Exists for humans to understand how policy evaluation occurred and details
export type NodeIdentifier = { // generated at evaluation time lazily
	display_name?: string;
	// address in policy tree as root...grandparent.parent.node where each is the name or type of the node
	address: string;
	type: NodeType;
  // whether the check passed at the single-node level; deferred for downstream deferredChecks
  result: NodeResult; 
}

// Policy violation representation used in output
export type Violation = {
	node: NodeIdentifier;
	explanation: string;
	// optional severity score, if applicable (useful for fully autonomous moderation w/ isComprehensive off)
	severity: number | undefined; 
}

// The object received by the worker or event handler using PolicyEngine
export type EvaluationResult = {
	violations: Violation[]; // list of all violations found during evaluation
  violation: boolean; // whether the content violates the policy; true if violations length > 0
  modNote: string; // 100 character of less, possibly incomplete summary-note of explanation
  trace: NodeIdentifier[]; // record of execution through policy tree
	// Whether evaluation was short-circuited in all_of, which indicates incompleteness of 
  // explanation/violations. Should be true if only caring about violation vs no violation
	earlyExit: boolean; 
}

// ===Definitions for policy evaluation process===

export type EvalRouter = (
    node: Policy, negate: boolean, parentAddress: string
) => void;

// A function that evaluates some type of individual PolicyNode node (any predicate or combinator)
// during recursive policy evaluation
export type NodeEvaluator = ({
  evalState, // evaluation state (info accumulator)
	policyNode, // the node this was called for
  negate, // whether evaluation should be negated in accordance w/ upstream not node
  nodeAddress, // name_or_type[index if applicable]/parentAddres
	evalNode, // function to do checks on a child node
  // content info and evaluation specifications
  doEarlyExit, // whether we do short-circuiting in all_of nodes or accumulate ALL violations
  text,
  imageUrl,
  history,
  models,
  apiKeys,
}: {
  evalState: EvaluationState;
	policyNode: Policy;
  negate: boolean;
	nodeAddress: string;
	evalNode: EvalRouter;
  doEarlyExit: boolean | null; 
  text: string;
  imageUrl?: string | null;
  history?: string[] | null;
  models?: ModelRegistry;
  apiKeys?: ApiKeys;
}) => void;

export type EvaluationState = {
	violations: Violation[]; // accumulated violations so far
	// address of parent node, or null if at root; 
	// used to build current node address in the form <node type>@<parent address>
	trace: NodeIdentifier[]; // record of execution through policy tree
	// whether short-circuiting has already occurred in this evaluation
	earlyExit: boolean; 
	// With earlyExit circuiting off, LLM calls can be batched outside of this helper. 
	// This is a list of expensive checks to do deferred for batching in the parent function.
	deferredChecks: DeferredCheck[]; 
}
