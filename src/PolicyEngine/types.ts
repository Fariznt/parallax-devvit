export type NodeType = "regex_check" | "safety_check" | "semantic_check" | "language_check" | "all_of" | "any_of" | "not"

export type SafetyCategory =
  | "sexual"
  | "sexual/minors"
  | "harassment"
  | "harassment/threatening"
  | "hate"
  | "hate/threatening"
  | "illicit"
  | "illicit/violent"
  | "self-harm"
  | "self-harm/intent"
  | "self-harm/instructions"
  | "violence"
  | "violence/graphic";

export type SafetyRule =
  {
    category: SafetyCategory; // category for this rule
		// at least one of escalation_range or violation_range
		// if score in violation_range => instant violation with no next_check
		// otherwise if score in escalation_range => go to next_check
    escalation_range?: [number, number];
    violation_range?: [number, number];
  } & (
    | { escalation_range: [number, number] }
    | { violation_range: [number, number] }
  );

export type SafetySpecification =
	// simple option; if category = True according to moderation API, violation 
	// (and escalate if next-check present)
	| { categories: SafetyCategory[] } 
	// advanced option; 
	| { rules: SafetyRule[] } 

// NodeSpecification: Defines types of checks and their fields
export type NodeSpecification = {
	// core functionality
  regex_check: { 
		patterns: string[];
		flags?: string;
	};
	safety_check: {
		scope: 'text' | 'image' | 'both';
	} & SafetySpecification;
  semantic_check: { semantic: string };
	language_check: { allowed: string[] }; // to be implemented using language.googleapis.com
};

// A type of check of the content
export type Predicate = {
  [K in keyof NodeSpecification]: {
    [P in K]: NodeSpecification[K];
  }
}[keyof NodeSpecification]

// A logical operator on predicate output (for aggregate values and negation)
export type Combinator =
    | { any_of: Policy[] }
    | { all_of: Policy[] }
    | { not: Policy[] | Policy }

// The representation of the content policy itself (the root or other nodes)
// Generated by parsing input JSON
export type Policy = {
  name?: string;
  next_check?: Policy;
	severity?: number; // optional severity score for violating this check
} & (Predicate | Combinator);

// === Definitions for PolicyEngine output ===

// Information corresponding to some predicate, returned by evaluateHelper so that
// expensive calls can be done with batching of all checks that wanted to use the 
// expensive tool (ex. LLM)
export type DeferredCheck = {
	type: 'semantic_check';
	rule: string;
	negate: boolean // flipped by a NOT node
}

// An identifier of nodes in the policy-tree generated lazily at evaluation time
// Exists for humans to understand how policy evaluation occurred and details
export type NodeIdentifier = { // generated at evaluation time lazily
	display_name?: string;
	// address in policy tree as root...grandparent.parent.node where each is the name or type of the node
	// uniqueness is not enforced (naming recommended for adjacent duplicate node types ex. who regexes under an any_of)
	address: string;
	type: NodeType;
}

// Policy violation representation used in output
export type Violation = {
	node: NodeIdentifier;
	explanation: string;
	// optional severity score, if applicable (useful for fully autonomous moderation w/ shortCircuit off
	severity: number | undefined; 
}

// The object received by the worker or event handler using PolicyEngine
export type EvaluationResult = {
	violations: Violation[]; // list of all violations found during evaluation
  violation: boolean; // whether the content violates the policy; true if violations length > 0
  modNote: string; // 100 character of less, possibly incomplete summary-note of explanation
  trace: NodeIdentifier[]; // record of execution through policy tree
	// Whether evaluation was short-circuited, which indicates incompleteness of explanation/violations, 
	// in accordance with traversal recorded in trace
	shortCircuit: boolean; 
}

// ===Definitions for policy evaluation process===

// A function that evaluates some type of individual PolicyNode node (any predicate or combinator)
// during recursive policy evaluation
export type NodeEvaluator = ({
  evalState, // evaluation state (info accumulator)
	policyNode, // the node this was called for
	nextCheck, // function to do checks on a child node
  // content info and evaluation specifications
  doShortCircuit, // whether we do short-circuiting in logic nodes
  text,
  imageUrl,
  history,
  apiKey,
}: {
  evalState: EvaluationState;
	policyNode: Policy;
	nextCheck: (node: Policy) => void;
  doShortCircuit: boolean | null; 
  text: string;
  imageUrl?: string | null;
  history?: string[] | null;
  apiKey?: string;
}) => void;

export type EvaluationState = {
	violations: Violation[]; // accumulated violations so far
	// address of parent node, or null if at root; 
	// used to build current node address in the form <node type>@<parent address>
	parentAddress: string | null; 
	trace: NodeIdentifier[]; // record of execution through policy tree
	// whether short-circuiting has already occurred in this evaluation
	shortCircuitOccurred: boolean; 
	// With short circuiting off, LLM calls can be batched outside of this helper. 
	// This is a list of expensive checks to do deferred for batching in the parent function.
	deferredChecks: DeferredCheck[]; 
}
