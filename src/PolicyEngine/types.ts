// === LLM arguments to PolicyEngine ===

export type ModelConfig = {
  modelName: string;
  baseUrl: string;
};

// === Definitions for Policy definition ===

export type SafetyCategory =
  | "sexual"
  | "sexual/minors"
  | "harassment"
  | "harassment/threatening"
  | "hate"
  | "hate/threatening"
  | "illicit"
  | "illicit/violent"
  | "self-harm"
  | "self-harm/intent"
  | "self-harm/instructions"
  | "violence"
  | "violence/graphic";

export type SafetyRule =
  {
    category: SafetyCategory; // category for this rule
		// at least one of escalation_range or violation_range
		// if score in violation_range => instant violation with no next_check
		// otherwise if score in escalation_range => go to next_check
    escalation_range?: [number, number];
    violation_range?: [number, number];
  } & (
    | { escalation_range: [number, number] }
    | { violation_range: [number, number] }
  );

export type SafetySpecification =
	// simple option; if category = True according to moderation API, violation 
	// (and escalate if next-check present)
	| { categories: SafetyCategory[] } 
	// advanced option; 
	| { rules: SafetyRule[] } 

// NodeSpecification: Defines types of checks and their fields
export type NodeSpecification = {
	// core functionality
  match_check: { 
		patterns: string[];
    blacklist?: boolean; // considered false by default i.e. pattern is whitelist
		flags?: string;
	};
	safety_check: {
		scope: 'text' | 'image' | 'both';
	} & SafetySpecification;
  semantic_check: { condition: string };
	language_check: { allowed: string[] }; // to be implemented using language.googleapis.com
  // NEW CHECKS ADDED HERE (subsets of match/safety, length, capitalization percentage)
};

// A type of check of the content
export type Predicate = {
  [K in keyof NodeSpecification]: {
    [P in K]: NodeSpecification[K];
  }
}[keyof NodeSpecification]

// A logical operator on predicate output (for aggregate values and negation)
export type Combinator =
    | { any_of: Policy[] }
    | { all_of: Policy[] }
    | { not: Policy }

// The representation of the content policy itself (the root or other nodes)
// Generated by parsing input JSON
export type Policy = {
  name?: string;
  next_check?: Policy;
	severity?: number; // optional severity score for violating this check
} & (Predicate | Combinator);

